#!/usr/bin/perl
#
# Logikprozessor.pl - Konfiguration
#

$eibd_backend_address='0.0.0'; # eigene Adresse zur Vermeidung von Zirkellogiken, ist oft auch '1.1.254'

# Zentrale Einstellungen, insb. für die Prowl Mechanik, s. u..
%settings=(
  prowl => {
    apikey => "*** hier eigenen API-Key eintragen***", 
    application => 'WireGate KNX',
    priority => 0,
    event => '[unbenanntes Ereignis]',
    description => '',
    url => ''
  }
);

%logic=(
    # 1. Alle Werte, die auf einer GA gesendet werden, werden mit 2 multipliziert auf einer anderen GA weitergegeben
    mal2 => { receive=>'9/5/201', transmit=>'9/5/202', translate => sub { 2*$input; }, },
    # das "undef" steht da einfach, weil uns der letzte Ergebniswert nicht interessiert
    # Namen von Logiken (hier "mal2" sind voellig frei, duerfen aber nicht mit einem "_" beginnen.
 
    # 2. Die Werte auf der ersten GA werden aufsummiert, das Ergebis auf der anderen GA gesendet.
    # Damit kann man bspw aus einem relativen Dimmwert einen absoluten Dimmwert machen. 
    sum => { receive=>'9/5/207', transmit=>'9/5/208', translate => sub { $state+$input; }, },
    # $state enthaelt das jeweils letzte Ergebnis.

    # 3. Wie oben, aber das Ergebnis limitiert auf den Bereich 0-100
    lsum => { receive=>'1/2/7', transmit=>'1/2/8', translate => sub { limit(0,$state+$input,100); }, },
 
    # 4. Memory-Funktion. Fuer KNX-Geräte, die kein Auslesen ihres Statuswerts zulassen (z.B. MDT DaliControl 
    # bei Einzel-EVG-Ansteuerung). Sehr einfach:
    memory => { transmit=>'1/2/9' },
    # Hier wird folgende Eigenschaft der Logik ausgenutzt: Wenn ein Write-Telegramm auf die Transmit-Adresse kommt, 
    # speichert der Logikprozessor den Wert immer automatisch ab. Eine Leseanfrage auf der transmit-GA hingegen wird 
    # immer mit dem letzten Wert (hier also dem gespeicherten) beantwortet. Eine receive-Adresse oder translate-Logik 
    # werden hier gar nicht gebraucht.

    # 5. Hier eine "Treppenlichtfunktion". Auf jeden Schreibzugriff auf die receive-Adresse wird 10min spaeter eine 0 an 
    # die transmit-Adresse (hier gleich) geschickt. 
    stair => { receive=>'1/2/9', transmit=>'1/2/9', delay=>600, translate => 0, },
    # Verzoegert wird uebrigens nur das Senden, nicht das Ausfuehren der translate-Routine. 
    # Neu ist hier der "delay"-Parameter, ausserdem der Spezialfall, dass translate einfach eine Konstante 
    # als Rueckgabewert spezifiziert.
    
    # Weitere Bemerkungen:
    # * translate darf nur entweder eine Konstante oder ausführbarer Code (sub {...}) sein.
    # * Damit im Fall transmit==receive der Translator nicht auf sein eigenes Schreibtelegramm immer wieder antwortet, 
    # wird nur dann gesendet, wenn Ergebnis!=Input oder Sender des empfangenen Telegramms!=$eibd_backend_address (Wiregate).
    # * Wenn waehrend der delay-Zeit erneut ein Receive-Telegramm empfangen wird, wird die Logik erneut ausgefuehrt und
    # die delay-Zeit beginnt von vorne (wie bei einem Treppenlicht die Leuchtzeit bei erneutem Druecken verlaengert wird).
    
    # Als weitere Sicherheit vor Zirkellogiken (die ja auch im Zusammenwirken mehrerer Logiken entstehen koennen) gibt es
    # die Klausel "cool=>...", die eine Logik nur dann zur Ausfuehrung zulaesst, wenn seit der letzten Ausfuehrung 
    # die spezifizierte Zahl von Sekunden verstrichen ist. Im obigen Beispiel also zB
    stair2 => { receive=>'1/2/9', transmit=>'1/2/9', delay=>600, translate => 0, cool=>650 },
    # So werden Zirkelschluesse komplett unmoeglich.

    # Hinweise zu cool: 
    # * bei gesetztem "cool=>..." wird die Ausfuehrung der Logik auf receive-Telegramme (nicht aber die Reaktion auf 
    # Schreib/Lesetelegramme wie in Bsp 4) fuer die definierte Zeit verhindert. 
    # * Falls gleichzeitig "delay=>..." spezifiziert ist, so wird die erneute Ausfuehrung der Logik bereits waehrend 
    # der delay-Zeit verhindert bis zum folgenden Schreibvorgang UND danach noch fuer die in cool=>... spezifizierte 
    # Anzahl Sekunden. 
    # * Ein Setzen von cool=>0 und delay=>10 hat den Effekt, dass die Ausfuehrung der Logik sofort nach Senden des 
    # transmit-Telegramms wieder erlaubt ist, aber NICHT waehrend der delay-Zeit (hier 10s). 

    # 5. Hier eine Logik, die den Input bei Eintreffen mit 2 multipliziert, das Resultat aber nur speichert und erst 
    # spaeter auf ein explizites Lesetelegramm hin auf der transmit-Adresse sendet. 
    req => { receive=>'1/2/9', transmit=>'1/2/9', transmit_only_on_request=>1, translate => sub { 2*$input; }, },

    # Uebrigens gibt es neben transmit_only_on_request auch transmit_on_startup und transmit_changes_only.

    # 6. Eine Logik, die einem Lichtanschalten gleich einen Dimmwert hinterherfeuert, und zwar tags und nachts einen verschiedenen:
    dim => { receive=>'2/2/9', transmit=>'2/3/9', translate => sub { return unless $input; $day ? 80 : 3; } },
    # Die Variablen $day_of_week (Mo...So), $calendar_week, $day_of_month (01-31), $month (01-12), $day_of_year (1-366), 
    # $year (2012), $date ('01/01'-'12/31'), $weekend (0 oder 1), $weekday (= nicht $weekend), $holiday (0 oder 1), 
    # $workingday (=nicht $weekend und nicht $holiday), $time_of_day ("08:34:02"), 
    # $hour ("08"), $day (1 falls zwischen 7 und 23 Uhr, 0 sonst) und $night (entsprechend umgekehrt) 
    # sind für diese Logiken vorbesetzt (bitte nicht darauf schreiben, koennte unverhergesehene Auswirkungen 
    # auf andere Logiken haben). $holiday beruecksichtigt dabei Neujahr, 1. Mai, 
    # 3. Oktober, Weihnachten/Ostern/Pfingsten, Christi Himmelfahrt und Fronleichnam als Feiertage.

    # 8. Eine einfache UND-Logik mit zwei Eingaengen. Falls ein Telegramm auf einer der beiden receive-GAs empfangen wird,
    # wird die andere Adresse noch ausgelesen, die Logik angewendet und das Ergebnis auf der transmit-GA uebermittelt
    und => { receive=>['1/2/12','1/2/13'], transmit=>'1/2/14', translate => sub { $input->[0] && $input->[1]; }, debug=>1 },
    # Das Flag debug=>1 bewirkt, dass diese (und nur diese!) Logik Meldungen ins Wiregate-Plugin-Log schreibt, die beim
    # Debugging der Logik hilfreich sein koennten.

    # 9. Ein komplexerer Fall nur zur Demonstration: hier besteht der Status des Logikprozessors aus mehreren Werten. 
    # Es wird immer die Summe aus letztem, vorletztem und aktuellem Wert gesendet, und zwar mit 30s Verzoegerung.
    complex => { receive=>'9/5/205', 
                 transmit=>'9/5/206', 
                 delay=>30, 
                 state => {val1=>0, val2=>0}, 
		 translate => sub { $state->{val2}=$state->{val1}; $state->{val1}=$state->{result}; 
				    $state->{val2}+$state->{val1}+$input; }, 
    },
    # Wenn state ein Hash ist, wird der letzte gesendete Wert in $state->{result} gespeichert.

    # 10. Eine Timer-Funktion. Hier eine Zeitschaltuhr, die immer am jeweils zweiten Dienstag jedes Monats 
    # um 08:00, um 10:00, zwischen 09:00 und 09:30 alle 2min und zwischen 18:00 und 20:00 jede volle Stunde 
    # eine 1 auf Transmit sendet
    wecker => { transmit=>'10/1/15', timer=>{ time=>['08:00','10:00','09:00+2m-09:30','18:00+1h-20:00'], 
					      day_of_month=>'8..14', day_of_week=>'Di' }, translate => 1 }, 
    # Logiken mit timer-Klausel weichen in mehreren Punkten von den bisherigen Logiken ab:
    # * sie ignorieren die delay-Klausel und die cool-Klausel
    # * Die transmit_only_on_request-Klausel funktioniert aber
    # * jeglicher Bustraffic auf receive-Adressen wird ignoriert. 
    # * Evtl. spezifizierte receive-Adressen werden aber beim Timer-Aufruf abgefragt, um das input-Array vorzubesetzen).
    # Weitere Infos zu Timer-Spezifikationen
    # * Als timer-Eintrag geht entweder ein einzelner Eintrag timer=>{...} wie oben oder eine Liste solcher Eintraege
    # time=>[{...},{...},{...},...]. 
    # * Jeder Eintrag MUSS eine Spezifikation time=>... (Varianten siehe Beispiel oben) enthalten. 
    # * Jeder Eintrag DARF zusaetzliche, die Geltungstage einschraenkende Klauseln wie year, month, day_of_year, 
    # day_of_month, calendar_week, day_of_week (Mo...So oder Mon...Sun oder 1...7) und date (Format 'MM/DD') enthalten. 
    # Solche Einträge duerfen Einzelwerte sein (year=>2012), Bereiche (day_of_month=>'8-14', date=>'02/12-03/15') 
    # oder auch wieder Listen von Werten/Bereichen. 
    # * Jeder Eintrag DARF zusaetzliche binaere (0 oder 1) Einschraenkungen enthalten: weekend, weekday, 
    # holiday und workingday (=weder holiday noch weekend). holiday beruecksichtigt dabei Neujahr, 1. Mai, 
    # 3. Oktober, Weihnachten/Ostern/Pfingsten, Christi Himmelfahrt und Fronleichnam als Feiertage.

    # 11. Schlussendlich wieder mal Werbung fuer die GA-Kurznamen. Verwendet man GA-Namen mit eindeutigem Kuerzel 
    # (Kuerzel=erstes Wort des Namens), so kann man ab Wiregate PL32 auch diese Kuerzel verwenden. 
    # Mit meinem (Frys) Namensschema funktioniert bspw. das folgende:
    D_SZ_Decke => { receive=>'LR_SZ_Decke_1', transmit=>'LK_SZ_Decke_1', 
		    translate => sub { limit(0,$state+20*$input,100); }, },
    # ist doch leserlicher, oder? Hier wird ein relativer Dimmwert (LR=Licht relativ, SZ=Schlafzimmer) durch Skalierung 
    # und Summierung in einen absoluten Wert umgewandelt   



    # 12. Prowl (http://www.prowlapp.com/) ist eine iPhone/iPad/i*-App zum Empfang von Growl-Kurznachrichten 
    # via Push. Da Prowl auch über eine Web-API Nachrichten entgegennehmen kann, ist eine Kopplung an eigene 
    # Anwendungen möglich. Für einen Minimalbetrieb ist Growl oder ein Mac nicht erforderlich: Es reicht die App auf dem 
    # Zielgerät und die Einrichtung von sog. API-Keys. Über prowl => ... lassen sich dann über den Logikprozessor 
    # Nachrichten per Push auf die App schicken.

    # Zur Vereinfachung der einzelnen Aufrufe können in der Konfigurationsdatei des Logikprozessors zentral Standardwerte 
    # hinterlegt werden. Dazu ist neben den %logic Hash noch ein %settings Hash zu legen, der bestimmte Einstellungen 
    # unterstützt, siehe oben.


    # Der Versand von Prowl-Nachrichten erfolgt nach der Verarbeitung von "translate", falls vorhanden. In der 
    # einfachsten Form erfolgt die Definition direkt mit dem gewünschten event-String (was die beschriebene Vergabe von
    # Standardwerten voraussetzt):

    simpleProwl => { receive => '1/2/3', prowl => 'Hello world!' }

    # Wenn nun auf der GA 1/2/3 ein Wert eingeht wird 'Hello world!' auf die App gepusht. prowl => ... kann auch einen Hash
    # entgegennehmen:

    hashProwl => {
      receive => '1/2/4',
      prowl => {
        application => 'Beschattung'
        event => 'Südseite AB'
      }
    }

    # Für komplexere Fälle kann auch eine sub übergeben werden, die dann einen passenden Hash zurückgeben muss. In die sub 
    # wird der Aufrufkontext übergeben, der den "input", das "result" und den "state" umfasst. Daneben stehen aber auch
    # vereinfachte Skalare zur Verfügung, $input, $state und $result.

    subProwl => {
      receive => '1/2/5',
      prowl => sub {
        my (%context) = @_;
        return (event => 'Rolladen Süd ' . ($input ? 'AB' : 'AUF'));
        # oder eben: return (event => 'Rolladen Süd ' . ($context{input} ? 'AB' : 'AUF'));
      }
    }

    # Der Versand an mehrere Empfänger ist durch die Definition von "apikey" als Array möglich:

    # apikey => [ "*** key 1 ***", "*** key 2 ***", ... ]



    # 13. transmit_changes_only beschränkt eine Logik darauf, dass nur Änderungen des States auf den Bus geschickt werden.
    # Dies kann bspw. genutzt werden, wenn zyklisch Temperaturwerte ausgewertet werden, aber nur "neue" Erkenntnisse auf
    # den Bus kommen sollen.

    logik_regenbrause_in_benutzung => {
      receive => '4/1/71',
      transmit => '6/1/0',
      transmit_changes_only => 1,
      translate => sub {
        return ($input gt 25) ? 1 : 0;
      }
    }

    ); 


