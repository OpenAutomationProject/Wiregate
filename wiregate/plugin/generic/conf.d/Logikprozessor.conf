#!/usr/bin/perl
#
# Logikprozessor.pl - Konfiguration
#

%logic=(
    # 1. Alle Werte, die auf einer GA gesendet werden, werden mit 2 multipliziert auf einer anderen GA weitergegeben
    mal2 => { receive=>'9/5/201', transmit=>'9/5/202', translate => sub { my (undef,$input)=@_; 2*$input; }, },
    # das "undef" steht da einfach, weil uns der letzte Ergebniswert nicht interessiert

    # 2. Die Werte auf der ersten GA werden aufsummiert, das Ergebis auf der anderen GA gesendet.
    # Damit kann man bspw aus einem relativen Dimmwert einen absoluten Dimmwert machen. 
    sum => { receive=>'9/5/207', transmit=>'9/5/208', translate => sub { my ($state,$input)=@_; $state+$input; }, },
    # $state enthaelt das jeweils letzte Ergebnis.

    # 3. Wie oben, aber das Ergebnis limitiert auf den Bereich 0-100
    lsum => { receive=>'1/2/7', transmit=>'1/2/8', translate => sub { my ($state,$input)=@_; limit(0,$state+$input,100); }, },
 
    # 4. Hier eine "Treppenlichtfunktion". Auf jeden Schreibzugriff auf die receive-Adresse wird 10min spaeter eine 0 an 
    # die transmit-Adresse (hier gleich) geschickt. Verzoegert wird uebrigens nur das Senden, nicht das Ausfuehren der 
    # translate-Routine. Neu ist hier der "delay"-Parameter, ausserdem der Spezialfall, dass translate einfach eine Konstante als
    # Rueckgabewert spezifiziert.
    stair => { receive=>'1/2/9', transmit=>'1/2/9', delay=>600, translate => 0, },
    # Damit im Fall transmit != receive der Logikprozessor nicht auf sein eigenes Schreibtelegramm immer wieder antwortet, wird nur dann gesendet,
    # wenn Ergebnis != Input oder Sender des empfangenen Telegramms!=0 (Wiregate).

    # 5. Memory-Funktion. Wenn ein Write-Telegramm auf die Transmit-Adresse kommt, speichert der Logikprozessor den Wert ab.
    # Das Flag "transmit_on_request" bewirkt, dass nichts gesendet wird, jedoch wird eine Leseanfrage auf der transmit-GA immer
    # mit dem letzten Wert (hier also dem gespeicherten) beantwortet. Damit laesst sich eine Speicherfunktion realisieren. 
    # Hier speichert Logikprozessor also den Input ab und sendet den errechneten (=gespeicherten) Wert NUR AUF ANFRAGE.
    memory => { transmit=>'1/2/9', transmit_only_on_request=>1 },
    # Eine receive-Adresse oder translate-Logik werden hier gar nicht gebraucht.

    # 6. Eine einfache UND-Logik mit zwei Eingaengen. Falls ein Telegramm auf einer der beiden receive-GAs empfangen wird,
    # wird die andere Adresse noch ausgelesen, die Logik angewendet und das Ergebnis auf der transmit-GA uebermittelt
    und => { receive=>['1/2/12','1/2/13'], transmit=>'1/2/14', translate => sub { my (undef,$input)=@_; $input->[0] && $input->[1]; }, },

    # 7. Ein komplexerer Fall nur zur Demonstration: hier besteht der Status des Logikprozessors aus mehreren Werten. 
    # Es wird immer die Summe aus letztem, vorletztem und aktuellem Wert gesendet, und zwar mit 30s Verzoegerung.
    complex => { receive=>'9/5/205', 
                 transmit=>'9/5/206', 
                 delay=>30, 
                 state => {val1=>0, val2=>0}, 
		 translate => sub { my ($state,$input)=@_; 
				    $state->{val2}=$state->{val1}; $state->{val1}=$state->{result}; 
				    $state->{val2}+$state->{val1}+$input; }, 
    },
    # Wenn state ein Hash ist, wird der letzte gesendete Wert in $state->{result} gespeichert.

    # 8. Schlussendlich wieder mal Werbung fuer die GA-Kurznamen. Setzt man im Skript Logikprozessor.pl $use_short_names=1
    # und verwendet GA-Namen mit eindeutigem Kuerzel (=erstes Wort des Namens), so funktioniert auch das folgende:
    D_SZ_Decke => { receive=>'LR_SZ_Decke_1', transmit=>'LK_SZ_Decke_1', 
		    translate => sub { my ($state,$input)=@_; limit(0,$state+20*$input,100); }, },
    # ist doch leserlicher, oder? Hier wird ein relativer Dimmwert durch Skalierung und Summierung 
    # in einen absoluten Wert umgewandelt   
    ); 



