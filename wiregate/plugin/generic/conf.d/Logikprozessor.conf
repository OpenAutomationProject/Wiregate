#!/usr/bin/perl
#
# Logikprozessor.pl - Konfiguration
#

$eibd_backend_address='1.1.254'; # eigene Adresse zur Vermeidung von Zirkellogiken

%logic=(
    # 1. Alle Werte, die auf einer GA gesendet werden, werden mit 2 multipliziert auf einer anderen GA weitergegeben
    mal2 => { receive=>'9/5/201', transmit=>'9/5/202', translate => sub { 2*$input; }, },
    # das "undef" steht da einfach, weil uns der letzte Ergebniswert nicht interessiert

    # 2. Die Werte auf der ersten GA werden aufsummiert, das Ergebis auf der anderen GA gesendet.
    # Damit kann man bspw aus einem relativen Dimmwert einen absoluten Dimmwert machen. 
    sum => { receive=>'9/5/207', transmit=>'9/5/208', translate => sub { $state+$input; }, },
    # $state enthaelt das jeweils letzte Ergebnis.

    # 3. Wie oben, aber das Ergebnis limitiert auf den Bereich 0-100
    lsum => { receive=>'1/2/7', transmit=>'1/2/8', translate => sub { limit(0,$state+$input,100); }, },
 
    # 4. Hier eine "Treppenlichtfunktion". Auf jeden Schreibzugriff auf die receive-Adresse wird 10min spaeter eine 0 an 
    # die transmit-Adresse (hier gleich) geschickt. Verzoegert wird uebrigens nur das Senden, nicht das Ausfuehren der 
    # translate-Routine. Neu ist hier der "delay"-Parameter, ausserdem der Spezialfall, dass translate einfach eine Konstante als
    # Rueckgabewert spezifiziert.
    stair => { receive=>'1/2/9', transmit=>'1/2/9', delay=>600, translate => 0, },
    # Verzoegert wird uebrigens nur das Senden, nicht das Ausfuehren der translate-Routine. 
    # Neu ist hier der "delay"-Parameter, ausserdem der Spezialfall, dass translate einfach eine Konstante 
    # als Rueckgabewert spezifiziert.

    # Weitere Bemerkungen:
    # * translate darf nur entweder eine Konstante oder ausführbarer Code (sub {...}) sein.
    # * Damit im Fall transmit==receive der Translator nicht auf sein eigenes Schreibtelegramm immer wieder antwortet, 
    # wird nur dann gesendet, wenn Ergebnis!=Input oder Sender des empfangenen Telegramms!=0 (Wiregate).
    
    # Damit im Fall transmit != receive der Logikprozessor nicht auf sein eigenes Schreibtelegramm immer wieder antwortet, 
    # wird nur dann gesendet, wenn Ergebnis != Input oder Sender des empfangenen Telegramms!=0 (Wiregate).

    # 5. Hier eine Logik, die den Input bei Eintreffen mit 2 multipliziert, das Resultat aber nur speichert und erst 
    # spaeter auf ein explizites Lesetelegramm hin auf der transmit-Adresse sendet. 
    req => { receive=>'1/2/9', transmit=>'1/2/9', transmit_on_request=>1, translate => sub { 2*$input; }, },

    # 6. Eine Logik, die einem Lichtanschalten gleich einen Dimmwert hinterherfeuert, und zwar tags und nachts einen verschiedenen:
    dim => { receive=>'2/2/9', transmit=>'2/3/9', translate => sub { return unless $input; $day ? 80 : 3; }, },
    # Die Variablen $day_of_week (Mo...So), $day_of_month (01-31), $month (01-12), $year (2012),
    # $weekend (0 oder 1), $weekday (= nicht $weekend), $time_of_day ("08:34:02"), 
    # $hour ("08"), $day (1 falls zwischen 7 und 23 Uhr, 0 sonst) und $night (entsprechend umgekehrt) 
    # sind für diese Logiken vorbesetzt (bitte nicht darauf schreiben, koennte unverhergesehene Auswirkungen 
    # auf andere Logiken haben).

    # 7. Memory-Funktion. Fuer KNX-Geräte, die kein Auslesen ihres Statuswerts zulassen (z.B. MDT DaliControl 
    # bei Einzel-EVG-Ansteuerung). Sehr einfach:
    memory => { transmit=>'1/2/9' },
    # Hier wird folgende Eigenschaft der Logik ausgenutzt: Wenn ein Write-Telegramm auf die Transmit-Adresse kommt, 
    # speichert der Logikprozessor den Wert immer automatisch ab. Eine Leseanfrage auf der transmit-GA hingegen wird 
    # immer mit dem letzten Wert (hier also dem gespeicherten) beantwortet. Eine receive-Adresse oder translate-Logik 
    # werden hier gar nicht gebraucht.

    # 8. Eine einfache UND-Logik mit zwei Eingaengen. Falls ein Telegramm auf einer der beiden receive-GAs empfangen wird,
    # wird die andere Adresse noch ausgelesen, die Logik angewendet und das Ergebnis auf der transmit-GA uebermittelt
    und => { receive=>['1/2/12','1/2/13'], transmit=>'1/2/14', translate => sub { $input->[0] && $input->[1]; }, debug=>1 },
    # Das Flag debug=>1 bewirkt, dass diese (und nur diese!) Logik Meldungen ins Wiregate-Plugin-Log schreibt, die beim
    # Debugging der Logik hilfreich sein koennten.

    # 9. Ein komplexerer Fall nur zur Demonstration: hier besteht der Status des Logikprozessors aus mehreren Werten. 
    # Es wird immer die Summe aus letztem, vorletztem und aktuellem Wert gesendet, und zwar mit 30s Verzoegerung.
    complex => { receive=>'9/5/205', 
                 transmit=>'9/5/206', 
                 delay=>30, 
                 state => {val1=>0, val2=>0}, 
		 translate => sub { $state->{val2}=$state->{val1}; $state->{val1}=$state->{result}; 
				    $state->{val2}+$state->{val1}+$input; }, 
    },
    # Wenn state ein Hash ist, wird der letzte gesendete Wert in $state->{result} gespeichert.

    # 10. Eine Timer-Funktion. Hier eine einfache Zeitschaltuhr, die immer um 8 Uhr und um 10:00 am jeweils zweiten 
    # Dienstag jedes Monats eine 1 auf Transmit sendet
    wecker => { transmit=>'10/1/15', timer=>{ time=>['08:00','10:00'], day_of_month=>[(8..14)], day_of_week=>'Di' }, translate => 1 }, 
    # Logiken mit timer-Klausel weichen in mehreren Punkten von den bisherigen Logiken ab:
    # * sie ignorieren die delay-Klausel und senden sofort, aber transmit_only_on_request funktioniert
    # * jeglicher Bustraffic auf receive-Adressen wird ignoriert. (Diese werden aber beim Timer-Aufruf abgefragt, 
    # um das input-Array vorzubesetzen).
    # Als timer-Eintrag geht entweder ein einzelnes Hash timer=>{...} wie oben oder eine Liste solcher Eintraege
    # time=>[{...},{...},{...},...]. Jeder Eintrag MUSS eine Spezifikation time=>'XX:XX' enthalten (auch das darf wieder 
    # eine Liste sein) und DARF zusaetzliche, die Geltungstage einschraenkende Klauseln wie year, month, day_of_month,
    # day_of_week, calendar_week enthalten.

    # 11. Schlussendlich wieder mal Werbung fuer die GA-Kurznamen. Setzt man im Skript Logikprozessor.pl $use_short_names=1
    # und verwendet GA-Namen mit eindeutigem Kuerzel (=erstes Wort des Namens), so funktioniert auch das folgende:
    D_SZ_Decke => { receive=>'LR_SZ_Decke_1', transmit=>'LK_SZ_Decke_1', 
		    translate => sub { limit(0,$state+20*$input,100); }, },
    # ist doch leserlicher, oder? Hier wird ein relativer Dimmwert durch Skalierung und Summierung 
    # in einen absoluten Wert umgewandelt   
    ); 



