#!/usr/bin/perl
#
# Translator.pl - Konfiguration

%trans=(

    # 1. Alle Werte, die auf einer GA gesendet werden, werden mit 2 multipliziert auf einer anderen GA weitergegeben
    mal2 => { receive=>'9/5/201', transmit=>'9/5/202', translate => sub { my ($state,$input)=@_; 2*$input; }, },

    # 2. Die Werte auf der ersten GA werden aufsummiert, das Ergebis auf der anderen GA gesendet.
    # Damit kann man bspw aus einem relativen Dimmwert einen absoluten Dimmwert machen. 
    sum => { receive=>'9/5/207', transmit=>'9/5/208', translate => sub { my ($state,$input)=@_; $state+$input; }, },
    # $state enthaelt das jeweils letzte Ergebnis.

    # 3. Wie oben, aber das Ergebnis limitiert auf den Bereich 0-100
    lsum => { receive=>'1/2/7', transmit=>'1/2/8', translate => sub { my ($state,$input)=@_; limit(0,$state+$input,100); }, },
 
    # 4. Schliesslich eine Memory-Funktion: wenn receive==transmit, so wird nur auf eine Leseanfrage gesendet. 
    # Hier speichert Translator also den Input ab und sendet den errechneten (=gespeicherten) Wert NUR AUF ANFRAGE 
    memory => { receive=>'1/2/9', transmit=>'1/2/10', translate => sub { my ($state,$input)=@_; $input; }, },
    
    # 5. Ein komplexerer Fall: hier besteht der Status des Translators aus mehreren Werten. 
    # Es wird immer die Summe aus letztem, vorletztem und aktuellem Wert gesendet.
    complex => { receive=>'9/5/205', transmit=>'9/5/206', state => {val1=>0, val2=>0}, 
		 translate => sub { my ($state,$input)=@_; 
				    $state->{val2}=$state->{val1}; $state->{val1}=$state->{result}; 
				    $state->{val2}+$state->{val1}+$input; }, },
    # Wenn state ein Hash ist, wird der letzte gesendete Wert in $state->{result} gespeichert.

    # 6. Schlussendlich wieder mal Werbung fuer die GA-Kurznamen. Setzt man im Skript Translator.pl $use_short_names=1
    # und verwendet GA-Namen mit eindeutigem Kuerzel (=erstes Wort des Namens), so funktioniert auch das folgende:
    D_SZ_Decke => { receive=>'LR_SZ_Decke', transmit=>'LK_SZ_Decke', 
		    translate => sub { my ($state,$input)=@_; limit(0,$state+20*$input,100); }, },
    # ist doch leserlicher, oder? Hier wird ein relativer Dimmwert durch Skalierung und Summierung 
    # in einen absoluten Wert umgewandelt

    ); 


